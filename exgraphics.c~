//Using SDL and standard IO
#include <SDL.h>
#include <stdio.h>
#include <assert.h>
//Screen dimension constants
const int SCREEN_WIDTH = 624;
const int SCREEN_HEIGHT = 624;

int flag = 0;

struct tile{
	SDL_Rect rectangle;
	int live;
	int dying;
	int born;
};

void map_update(struct tile map[26][26], SDL_Surface* screenSurface);

struct tile *tile_getNeighbors(struct tile map[26][26], int i, int j)
{
	struct tile *neighbors = malloc(sizeof(struct tile[9]));
	int k;
	int p;
	int c = 0;
	for (k = i-1; k <= i+1; k++)
	{
		for(p = j-1; p <= j+1; p++)
		{

			if (k == i && p == j)
				continue;
			int x = k; int y = p;
			if(k < 0)
				x = 25;
			else if (k>25)
				x = 0;
			if (p < 0)
				y = 25;
			else if (p>25)
				y = 1;
			neighbors[c] = map[x][y];
			c++;
		}
	}
	return neighbors;

}

int tile_liveNeighbors(struct tile *neighbors)
{
	int i;
	int c = 0;
	for (i = 0; i < 8; i++)
	{
		if (neighbors[i].live !=0)
			c++;
	}
	return c;
}

void handleMouseEvent(SDL_Event e, struct tile map[26][26], SDL_Surface* screenSurface)
{
	int x = e.button.x;
	int y = e.button.y;
	assert(0 <= y && y <= 624 && 0 <= x && x <= 624);

	struct tile* toChange = &map[x/24][y/24];
	if(toChange->live == 1)
	{
		toChange->live = 0;
		SDL_FillRect( screenSurface, &(toChange->rectangle), SDL_MapRGB( screenSurface->format, 0, 0, 0 ) );
		
	}	
	else
	{
		toChange->live = 1;
		SDL_FillRect( screenSurface, &(toChange->rectangle), SDL_MapRGB( screenSurface->format, 255, 255, 255) );	
	}
}

void map_update(struct tile map[26][26], SDL_Surface* screenSurface)
{
	int i; int j;
	if(flag != 0)
	{
		for(i = 0; i < 26; i++)
		{
			for (j = 0; j < 26; j++)
			{
				struct tile *neighbors = tile_getNeighbors(map, i, j);
				int living = tile_liveNeighbors(neighbors);
				free(neighbors);
				if(living > 3)
					map[i][j].dying = 1;
				else if(living == 3)
					map[i][j].born = 1;
				else if(living <= 1)
					map[i][j].dying = 1;
			}
		}
		for(i = 0; i < 26; i++)
		{
			for (j = 0; j < 26; j++)
			{
				if(map[i][j].dying == 1)
				{
					map[i][j].live = 0;
					map[i][j].dying = 0;
				}
				if(map[i][j].born == 1)
				{
					map[i][j].live = 1;
					map[i][j].born = 0;
				}
				if (map[i][j].live == 1)
				{
					SDL_FillRect( screenSurface, &(map[i][j].rectangle), SDL_MapRGB( screenSurface->format, 255, 255, 255 ) );
				}
				else
				{
					SDL_FillRect( screenSurface, &(map[i][j].rectangle), SDL_MapRGB( screenSurface->format, 0, 0, 0 ) );
				}
			}
		}
	}
	else
	{
		for(i = 0; i < 26; i++)
				{
					for (j = 0; j < 26; j++)
					{
						if (map[i][j].live == 1)
						{
							SDL_FillRect( screenSurface, &(map[i][j].rectangle), SDL_MapRGB( screenSurface->format, 255, 255, 255 ) );
						}
						else
						{
							SDL_FillRect( screenSurface, &(map[i][j].rectangle), SDL_MapRGB( screenSurface->format, 0, 0, 0 ) );
						}
					}
				}
	}
	flag = 1;

}

void eventsLoop(SDL_Event e, struct tile map[26][26], SDL_Surface* screenSurface, int* x, int* y, int* quit, int* pause)
{
	while(SDL_PollEvent( &e ) > 0)
            	{
			//If the user has Xed out the window
       		     if( e.type == SDL_QUIT )
       		     {
      		          //Quit the program
      		          *quit = 0;
      		     }
		     else if(e.type == SDL_MOUSEMOTION || e.type == SDL_MOUSEBUTTONDOWN)
		     {
			  if(e.type == SDL_MOUSEBUTTONDOWN)
			{
				handleMouseEvent(e, map, screenSurface);
				*x = e.button.x/24;
				*y = e.button.y/24;
			}
			  else if(SDL_GetMouseState(NULL, NULL)&SDL_BUTTON(1))
			{
				if(e.button.x/24 != *x || e.button.y/24 != *y)
				{
			 		handleMouseEvent(e, map, screenSurface);
					*x = e.button.x/24;
					*y = e.button.y/24;					
				}
			}
		     }
		     else if(e.type == SDL_KEYDOWN)
			{
				*pause = !*pause;
			}
		}
} 

int main( int argc, char* args[] )
{
    struct tile map[26][26];

    //The window we'll be rendering to
    SDL_Window* window = NULL;
    
    //The surface contained by the window
    SDL_Surface* screenSurface = NULL;

    //Initialize SDL
    if( SDL_Init( SDL_INIT_VIDEO ) < 0 )
    {
        printf( "SDL could not initialize! SDL_Error: %s\n", SDL_GetError() );
    }
    else
    {
        //Create window
        window = SDL_CreateWindow( "Conway's Game of Life", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN );
        if( window == NULL )
        {
            printf( "Window could not be created! SDL_Error: %s\n", SDL_GetError() );
        }
	else
        {
	    SDL_Rect rectangle;
	    rectangle.x = 10;
	    rectangle.y = 10;
	    rectangle.h = 24;
	    rectangle.w = 24;

	    int i;
	    int j;
	    

	    for (i = 0; i < 26; i++)
	    {
	    	for(j = 0; j < 26; j++)
			{
				map[i][j].rectangle.x = i*24;
				map[i][j].rectangle.y = j*24;
				map[i][j].rectangle.w = 24;
				map[i][j].rectangle.h = 24;
				map[i][j].live = 0;
				map[i][j].dying = 0;
				map[i][j].born = 0;
			}
	    }

            //Get widow surface
            screenSurface = SDL_GetWindowSurface(window);
		SDL_Event e;
		int quit = 1;
		int x = -1;
		int y = -1;
		int pause = 1;
            while(quit == 1)
            {
		map_update(map, screenSurface);		
		eventsLoop(e, map, screenSurface, &x, &y, &quit, &pause);
		
		
    		//Update the surface
    		SDL_UpdateWindowSurface( window );
	  	SDL_Delay(500);
		if(pause == 1)
		{			 
			while(pause == 1 && quit == 1)
			{
				eventsLoop(e, map, screenSurface, &x, &y, &quit, &pause);		
				SDL_UpdateWindowSurface( window );
			}
		}
           }
        }
    }
//Destroy window
    SDL_DestroyWindow( window );
    //Quit SDL subsystems
    SDL_Quit();

    return 0;
}

